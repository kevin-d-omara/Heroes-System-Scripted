#include !/HeroesSystemTacticalScale/GameEngine/Model/UnitOfMeasurement
#include !/TabletopSimulator/Vector2
#include !/TabletopSimulator/Vector3

#include !/HeroesSystemTacticalScale/GameEngine/Persistence/Database

--[[
## Class
class BattlefieldView
{
    -- Fields
    BattlefieldModel Model

    -- Constructors
    BattlefieldView:new(parameters)
    BattlefieldView(parameters)

    -- Methods
    void Materialize()

    void PlaceOnTerrainSpace(path, terrainAlias, index, options)
    void PlaceOnTerrainInterspace(path, terrainAlias, index, options)
    void PlaceOnBattlefieldSpace(path, index, options)
    void PlaceOnBattlefieldInterspace(path, index, options) options)
    void PlaceOnBattlefield(path, worldPosition, options)

    Vector2 GetWorldPositionForTerrainSpace(terrainAlias, index)
    Vector2 GetWorldPositionForTerrainInterspace(terrainAlias, index)
    Vector2 GetWorldPositionForBattlefieldSpace(index)
    Vector2 GetWorldPositionForBattlefieldInterspace(index)
}

## Summary
Physical representation of the Battlefield. Offers methods for placing tiles on the Battlefield.
--]]

local BattlefieldView = {}

-- Can create a new BattlefieldView instance by calling either BattlefieldView:new() or just BattlefieldView().
setmetatable(BattlefieldView, { __call = function(self, ...) return self:new(...) end })

--[[
## Parameters
<BattlefieldModel> model: All data needed to physically manifest the BattlefieldView.
--]]
function BattlefieldView:new(model)
    local obj = {}
    setmetatable(obj, self)
    self.__index = self
    self.__call = function(self, ...) return self:new(...) end

    obj.Model = model

    return obj
end

--[[
## Summary
Place all the Terrain Boards and Terrain Tiles and Objects onto the table.
Pieces are centered around the center of the table.
--]]
function BattlefieldView:Materialize(parameters)
    local parameters = parameters or {}

    -- Lay Terrain Boards.
    for k,board in pairs(self.Model.TerrainBoards) do
        local path      = board[1]
        local index     = board[2].index
        local options   = board[2]
        options.lockObject = true
        self:PlaceOnBattlefieldSpace(path, index, options)
    end

    -- Lay Terrain Tiles.
    for k,tile in pairs(self.Model.TerrainTiles) do
        local path      = tile[1]
        local alias     = tile[2]
        local index     = tile[3]
        local indexType = tile[4]
        local options   = tile[5]
        options.lockObject = true

        if indexType == "space" then
            self:PlaceOnTerrainSpace(path, alias, index, options)
        elseif indexType == "interspace" then
            self:PlaceOnTerrainInterspace(path, alias, index, options)
        else
            error()
        end
    end

    -- Lay Objects
    for k,object in pairs(self.Model.Objects) do
        local path      = object[1]
        local alias     = object[2]
        local index     = object[3]
        local indexType = object[4]
        local options   = object[5]

        if indexType == "space" then
            self:PlaceOnTerrainSpace(path, alias, index, options)
        elseif indexType == "interspace" then
            self:PlaceOnTerrainInterspace(path, alias, index, options)
        else
            error()
        end
    end
end

function BattlefieldView:PlaceOnTerrainSpace(path, terrainAlias, index, options)
    self:PlaceOnBattlefield(path, self:GetWorldPositionForTerrainSpace(terrainAlias, index), options)
end

function BattlefieldView:PlaceOnTerrainInterspace(path, terrainAlias, index, options)
    self:PlaceOnBattlefield(path, self:GetWorldPositionForTerrainInterspace(terrainAlias, index), options)
end

function BattlefieldView:PlaceOnBattlefieldSpace(path, index, options)
    self:PlaceOnBattlefield(path, self:GetWorldPositionForBattlefieldSpace(index), options)
end

function BattlefieldView:PlaceOnBattlefieldInterspace(path, index, options)
    self:PlaceOnBattlefield(path, self:GetWorldPositionForBattlefieldInterspace(index), options)
end

--[[
## Summary
Place the object onto the battlefield on top of any Objects already existing in the Game World.

The object is placed on top of anything already existing in the Game World, regardless of where it came from. For example, if there are dice lying on the battlefield and the object is supposed to be placed there, it will be placed on top of the dice.

## Parameters
<string> path: The path to the resource (i.e. "HoN.Core_Box.Terrain.C6_A").
<Vector3> worldPosition: The (x,y,z) position in World Coordinates to place this object.
<table> options: A table with the following key-value pairs:
    <float> rotationDegrees: Degrees clockwise to rotate this object after placing it.
        [Optional, defaults to 0 degrees.]
    <bool> isFlipped: True if the object should be placed on its reverse side. False if the front should be showing.
        [Optional, defaults to false.]
--]]
function BattlefieldView:PlaceOnBattlefield(path, worldPosition, options)
    local options         = options or {}
    local rotationDegrees = options.rotation  or 0
    local isFlipped       = options.isFlipped or false

    local callback_function = function(obj)
        worldPosition = worldPosition + Vector3.up * BattlefieldView.GetMinimumPlacementHeight(worldPosition, obj)
        obj.setPosition(worldPosition)

        if options.lockObject then
            obj.setLock(true)
        end
    end

    Database.PlaceObject(path, {
        position = {100,1,1}, -- TODO: Make this somewhere else, like on top of the bag or something.
        rotation = {0,rotationDegrees,0},
        flip = isFlipped,
        callback_function = callback_function,
    })
end

--[[
## Summary
Return the height (y-axis) that the object should be placed so that it is perfectly above all other objects below it.

The return value should be used as the y-component of the position passed into `object.setPosition or object.setPositionSmooth` (see: https://api.tabletopsimulator.com/object/#setpositionsmooth).

## Parameters
<Vector3> worldPosition: The (x,y,z) point in the Game World where the object will be placed. The y component is ignored.
<Tabletop Simulator Object> object: The object that will be placed. Used to get the object's bounds (https://api.tabletopsimulator.com/object/#getbounds).
--]]
function BattlefieldView.GetMinimumPlacementHeight(worldPosition, object)
    local MAX_CAST_HEIGHT = 1000    -- The Maximum height (y-axis) from which a Physics box cast will still return hits.

    local bounds = object.getBounds()
    local castSize = Vector3(bounds.size) * 0.99    -- Scale down slightly to avoid clipping with closely placed neighbors.
    local castOrigin = Vector3(
        worldPosition.x,
        MAX_CAST_HEIGHT,
        worldPosition.z
    )
    local hits = Physics.cast({
        origin       = castOrigin,
        direction    = Vector3.down,
        type         = 3,           -- Box shaped cast.
        size         = castSize,
    })

    -- Get the maximum y-value from among the hit objects.
    -- Despite the documentation, entries are not in the order of being hit, so hits[1] is not the heighest object.
    -- See: https://api.tabletopsimulator.com/physics/#cast
    local maxHeight = 0
    for i,hit in ipairs(hits) do
        local height = hit.point.y
        if height > maxHeight then
            maxHeight = height
        end
    end

    -- In Tabletop Simulator, the position of a game object is at the *bottom* of the physical object, not the center.
    -- The y component of object.setPosition(vector) must correspond to where the bottom of the object should be placed.
    return (maxHeight + bounds.size.y/2) + bounds.offset.y
end

--[[
Return the World Coordinates (x,y,z) for the Terrain Coordinates (x,y).

The Terrain Coordinates are measured in spaces and start from (1,1) which is the bottom left space of the battlefield.
The World Coordinate's y component (height) is always 0.
--]]
function BattlefieldView:GetWorldPositionForBattlefieldSpace(cell)
    local cell = Vector3(cell)
    local originBattlefieldWorld = Vector3.zero
    local originBattlefieldCell  = Vector3((self.Model.Width + 1)/2, (self.Model.Height + 1)/2, 0)

    local worldPositionCell =
        (originBattlefieldCell - cell) * UnitOfMeasurement.Cell + originBattlefieldWorld

    return Vector3(
        -- Rotate from local coordinate system to world coordinate system.
        worldPositionCell.x,   -- world x-axis = local x-axis
        worldPositionCell.z,   -- world y-axis = local z-axis
        worldPositionCell.y    -- world z-axis = local y-axis
    )
end

function BattlefieldView:GetWorldPositionForBattlefieldInterspace(index)
    return self:GetWorldPositionForBattlefieldSpace(index)
end

function BattlefieldView:GetWorldPositionForTerrainSpace(terrainAlias, index)
    return self:GetWorldPositionForBattlefieldSpace(self.Model:ConvertTerrainSpaceToBattlefieldSpace(terrainAlias, index))
end

function BattlefieldView:GetWorldPositionForTerrainInterspace(terrainAlias, index)
    return self:GetWorldPositionForBattlefieldInterspace(self.Model:ConvertTerrainInterspaceToBattlefieldInterspace(terrainAlias, index))
end
