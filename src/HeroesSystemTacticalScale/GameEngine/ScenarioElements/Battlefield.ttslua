#include !/HeroesSystemTacticalScale/GameEngine/Model/UnitOfMeasurement
#include !/TabletopSimulator/Vector2
#include !/TabletopSimulator/Vector3

#include !/HeroesSystemTacticalScale/GameEngine/Persistence/Database
function Place(path, parameters)
    local ttsObject = Database.GetData(path)
    GetNestedObjectFromGuids(ttsObject:GetParentGuids(), parameters)
end

--[[
## Class
class Battlefield
{
    -- Fields
    int Width
    int Height
    array Terrain
    array Elements
    array AliasToTerrainMap

    -- Constructors
    Battlefield:new(parameters)
    Battlefield(parameters)

    -- Methods
    void PlaceAllTiles(parameters)

    void PlaceOnTerrainSpace(URI, terrainAlias, index, options)                 -- PlaceOnBattlefield(URI, GetWorldPositionForTerrainSpace(terrainAlias, index), options)
    void PlaceOnTerrainInterspace(URI, terrainAlias, index, options)            -- PlaceOnBattlefield(URI, GetWorldPositionForTerrainInterspace(terrainAlias, index), options)
    void PlaceOnBattlefieldSpace(URI, index, options)                           -- PlaceOnBattlefield(URI, GetWorldPositionForBattlefieldSpace(index), options)
    void PlaceOnBattlefieldInterspace(URI, index, options)                      -- PlaceOnBattlefield(URI, GetWorldPositionForBattlefieldInterspace(index), options)

    Vector2 GetWorldPositionForTerrainSpace(terrainAlias, index)                -- GetWorldPositionForBattlefieldSpace(ConvertTerrainSpaceToBattlefieldSpace(terrainAlias, index))
    Vector2 GetWorldPositionForTerrainInterspace(terrainAlias, index)           -- GetWorldPositionForBattlefieldInterspace(ConvertTerrainInterspaceToBattlefieldInterspace(terrainAlias, index))
    Vector2 GetWorldPositionForBattlefieldSpace(index)
    Vector2 GetWorldPositionForBattlefieldInterspace(index)

    Vector2 ConvertTerrainSpaceToBattlefieldSpace(terrainAlias, index)
    Vector2 ConvertTerrainInterspaceToBattlefieldInterspace(terrainAlias, index)

    void PlaceOnBattlefield(URI, worldPosition, options)
}

## Summary
A representation of a Heroes System battlefield, including both terrain tiles and the elements that go on top (i.e. houses, objectives, units, etc.).

## Coordinate Systems
There are two coordinate systems used to describe the location of Terrain and Elements.
In all cases, origin is at the bottom left with +x to the right and +y to the top (Cartesian Coordinates).

Terrain Coordinates:
    Measured by either "tile" or "space":
    tile: (1,1) is the bottom-left terrain tile of the battlefield. Each unit is an entire terrain tile (7x7 spaces).
    space: (1,1) is the bottom-left space of the bottom-left terrain tile of the battlefield. Each unit is a single space.

Element Coordinates:
    Measured by either "space" or "interspace":
    space: (1,1) is the bottom-left space of the terrain tile. Each unit is a single space.
    interspace: (0,0) is the bottom-left interspace of the terrain tile (physically on the corner of the tile). Each unit is a single interspace.

## Notes
Internally, all Terrain Coordinates are measured by "spaces".
--]]

local Battlefield = {}

-- Can create a new Battlefield instance by calling either Battlefield:new() or just Battlefield().
setmetatable(Battlefield, { __call = function(self, ...) return self:new(...) end })

--[[
## Parameters
<table> parameters: A table with the following key-value pairs:
    <int> Width:  The number of terrain tiles or spaces wide the battlefield is (tiles if the Terrain array elements don't have an "index" key, spaces otherwise).
    <int> Height: The number of terrain tiles or spaces high the battlefield is (tiles if the Terrain array elements don't have an "index" key, spaces otherwise).
    <table> Terrain: An array of terrain tiles, which are arrays with the following elements:
        <string> [1] (path): The URI for this terrain tile resource (i.e. "HoN.Core_Box.Terrain.C6_A").
        <table> [2] (options): The following key-value pairs:
            [Optional, defaults to having no options.]
            <Vector2> index: The (x,y) Terrain Coordinates (in spaces) of this tile.
                [Optional, defaults to the center space of this tile on the battlefield, according to its order within the array. Tiles are ordered left-to-right, top-to-bottom.]
            <Vector2> bounds: The width and height (in spaces) of this tile after it has been rotated (i.e. a 2x3 tile that is rotated 90 degrees would have bounds of 3x2).
                [Optional, defaults to Vector2(7,7).]
            <string> alias: The name/key to use when placing Elements onto this tile.
                [Optional, defaults to the leaf key in the path URI (i.e. "C6_A" for "HoN.Core_Box.Terrain.C6_A")].
            <float> rotation: Degrees clockwise to rotate this tile.
                [Optional, defaults to 0 degrees.]
            <bool> isFlipped: True if the tile should be placed on its reverse side. False if the front should be showing.
                [Optional, defaults to false.]
    <table> Elements: An array of terrain elements, which are arrays with the following elements:
        [Optional, defaults to having no terrain elements.]
        <string> [1] (path): The URI for this terrain element resource (i.e. "HoN.Core_Box.Terrain.House_1x1").
        <Vector2> [2] (tile): The alias of the terrain tile this element will be placed on.
        <Vector2> [3] (index): The (x,y) Element Coordinates on the terrain tile that this element will be placed. Is measured according to the "indexType".
        <string> [4] (indexType): Either "space" or "interspace". (see Coordinate Systems)
        <table> [5] (options): The following key-values pairs:
            [Optional, defaults to having no options.]
            <float> rotation: Degrees clockwise to rotate this tile.
                [Optional, defaults to 0 degrees.]
            <bool> isFlipped: True if the tile should be placed on its reverse side. False if the front should be showing.
                [Optional, defaults to false.]
--]]
function Battlefield:new(parameters)
    local errorMsg = Battlefield._ValidateParameters(parameters)
    if errorMsg ~= nil then
        error(errorMsg)
    end

    if Battlefield._TerrainIndexIsMissing(parameters.Terrain) then
        Battlefield._AddIndexToTerrainTiles(parameters.Terrain, parameters.Width, parameters.Height)

        -- Convert from terrain tiles (7x7 spaces) to individual spaces.
        parameters.Width  = parameters.Width  * 7
        parameters.Height = parameters.Height * 7
    end

    -- Defaults.
    for k,v in ipairs(parameters.Terrain) do
        -- Set default values.
        v[2].bounds    = v[2].bounds    or {7,7}
        v[2].rotation  = v[2].rotation  or 0
        v[2].isFlipped = v[2].isFlipped or false
        if v[2].alias == nil then
            local pathArray = SplitString(v[1], '.')
            v[2].alias = pathArray[#pathArray]  -- The default alias is the leaf key in the path (i.e. 'C6_A' for 'HoN.Core_Box.Terrain.C6_A').
        end

        -- Transform to Vector2.
        v[2].index  = Vector2(v[2].index)
        v[2].bounds = Vector2(v[2].bounds)
    end
    for k,v in ipairs(parameters.Elements) do
        -- Set default values.
        v[5] = v[5] or {}
        v[5].rotation  = v[5].rotation  or 0
        v[5].isFlipped = v[5].isFlipped or false

        -- Transform to Vector2.
        v[3] = Vector2(v[3])
    end

    -- A map from terrain alias to terrain tile.
    local aliasToTerrainMap = {}
    for i,v in ipairs(parameters.Terrain) do
        aliasToTerrainMap[v[2].alias] = v
    end

    local obj = {}
    setmetatable(obj, self)
    self.__index = self
    self.__call = function(self, ...) return self:new(...) end

    obj.Width    = parameters.Width
    obj.Height   = parameters.Height
    obj.Terrain  = parameters.Terrain
    obj.Elements = parameters.Elements
    obj.AliasToTerrainMap = aliasToTerrainMap

    return obj
end

--[[
## Summary
Place all the Terrain Tiles and Terrain Elements onto the table.
Pieces are centered around the center of the table.
--]]
function Battlefield:PlaceAllTiles()
    -- Lay Terrain.
    for k,tile in pairs(self.Terrain) do
        local uri       = tile[1]
        local index     = tile[2].index
        local options   = tile[2]
        self:PlaceOnBattlefieldSpace(uri, index, options)
    end

    -- Lay Elements.
    for k,tile in pairs(self.Elements) do
        local uri       = tile[1]
        local alias     = tile[2]
        local index     = tile[3]
        local indexType = tile[4]
        local options   = tile[5]

        -- Temporary hack.
        if indexType == "space" then
            local worldPosition = self:GetWorldPositionForTerrainSpace(alias, index) + Vector3.up
            self:PlaceOnBattlefield(uri, worldPosition, options)
        elseif indexType == "interspace" then
            local worldPosition = self:GetWorldPositionForTerrainInterspace(alias, index) + Vector3.up
            self:PlaceOnBattlefield(uri, worldPosition, options)
        else
            error()
        end
    end
end

function Battlefield:PlaceOnBattlefield(URI, worldPosition, options)
    worldPosition = worldPosition + Vector3.up * UnitOfMeasurement.MinimumPlacementHeight

    local options         = options or {}
    local rotationDegrees = options.rotation  or 0
    local isFlipped       = options.isFlipped or false

    Place(URI, {
        position = worldPosition,
        rotation = {0,rotationDegrees,0},
        flip = isFlipped,
    })
end

function Battlefield:PlaceOnTerrainSpace(URI, terrainAlias, index, options)
    self:PlaceOnBattlefield(URI, self:GetWorldPositionForTerrainSpace(terrainAlias, index), options)
end

function Battlefield:PlaceOnTerrainInterspace(URI, terrainAlias, index, options)
    self:PlaceOnBattlefield(URI, self:GetWorldPositionForTerrainInterspace(terrainAlias, index), options)
end

function Battlefield:PlaceOnBattlefieldSpace(URI, index, options)
    self:PlaceOnBattlefield(URI, self:GetWorldPositionForBattlefieldSpace(index), options)
end

function Battlefield:PlaceOnBattlefieldInterspace(URI, index, options)
    self:PlaceOnBattlefield(URI, self:GetWorldPositionForBattlefieldInterspace(index), options)
end

--[[
Return the World Coordinates (x,y,z) for the Terrain Coordinates (x,y).

The Terrain Coordinates are measured in spaces.
The World Coordinate's y component (height) is always 0.
--]]
function Battlefield:GetWorldPositionForBattlefieldSpace(cell)
    local cell = Vector3(cell)
    local originBattlefieldWorld = Vector3.zero
    local originBattlefieldCell  = Vector3((self.Width + 1)/2, (self.Height + 1)/2, 0)

    local worldPositionCell =
        (originBattlefieldCell - cell) * UnitOfMeasurement.Cell + originBattlefieldWorld

    return Vector3(
        -- Rotate from local coordinate system to world coordinate system.
        worldPositionCell.x,   -- world x-axis = local x-axis
        worldPositionCell.z,   -- world y-axis = local z-axis
        worldPositionCell.y    -- world z-axis = local y-axis
    )
end

function Battlefield:GetWorldPositionForBattlefieldInterspace(index)
    return self:GetWorldPositionForBattlefieldSpace(index)
end

function Battlefield:GetWorldPositionForTerrainSpace(terrainAlias, index)
    return self:GetWorldPositionForBattlefieldSpace(self:ConvertTerrainSpaceToBattlefieldSpace(terrainAlias, index))
end

function Battlefield:GetWorldPositionForTerrainInterspace(terrainAlias, index)
    return self:GetWorldPositionForBattlefieldInterspace(self:ConvertTerrainInterspaceToBattlefieldInterspace(terrainAlias, index))
end

function Battlefield:ConvertTerrainSpaceToBattlefieldSpace(terrainAlias, index)
    local tile = self.AliasToTerrainMap[terrainAlias]
    local bounds = tile[2].bounds

    local centerTileBattlefield = tile[2].index                                 -- The (x,y) Terrain Coordinates of the center of this tile in the battlefield.
    local centerTileTerrain = Vector2((bounds.x + 1)/2, (bounds.y + 1)/2)       -- The (x,y) Element Coordinates of the center of this tile within the tile itself.
    local indexBattlefield = index - centerTileTerrain + centerTileBattlefield  -- The (x,y) Terrain Coordinates of the index in the battlefield.

    return indexBattlefield
end

function Battlefield:ConvertTerrainInterspaceToBattlefieldInterspace(terrainAlias, index)
    return self:ConvertTerrainSpaceToBattlefieldSpace(terrainAlias, Vector2(index) + {0.5, 0.5})
end

--------------------------------------------------------------------------------
-- [[ Initialization methods ]] ------------------------------------------------
--------------------------------------------------------------------------------

function Battlefield._ValidateParameters(parameters)
    if type(parameters) ~= 'table'          then return "Argument [1] parameters: table expected, but got " .. tostring(type(parameters)) .. "." end
    if type(parameters.Width) ~= 'number'   then return "Argument [1] parameters.Width: integer number expected, but got " .. tostring(type(parameters.Width)) .. "." end
    if type(parameters.Height) ~= 'number'  then return "Argument [1] parameters.Height: integer number expected, but got " .. tostring(type(parameters.Height)) .. "." end
    if type(parameters.Terrain) ~= 'table'  then return "Argument [1] parameters.Terrain: table expected, but got " .. tostring(type(parameters.Terrain)) .. "." end
    if #parameters.Terrain < 1              then return "Argument [1] parameters.Terrain: array expected, but 0 elements found." end

    return nil
end

--[[
Returns true if the first terrain tile does not include an "indexType" key.
ex: tile = {"SoN.Core_Box.Terrain.S3_B", {index = {1, 1}, rotation = -90}}
--]]
function Battlefield._TerrainIndexIsMissing(terrainTiles)
    local tile = terrainTiles[1]    -- {"SoN.Core_Box.Terrain.S3_B", {index = {1, 1}, rotation = -90}}
    local params = tile[2]          -- {index = {1, 1}, rotation = -90}
    if params == nil or params.index == nil then
        return true
    else
        return false
    end
end

--[[
## Summary
Populate the "index" option with the coordinates of each tile's center space.
Indices move left-to-right, top-to-bottom in a grid of size (width, height).

## Example
For a 2 by 2 battlefield that looks like:
A|B
C|D
{
    {"HoN.Core_Box.Terrain.A"},
    {"HoN.Core_Box.Terrain.B", {rotation = 90}},
    {"HoN.Core_Box.Terrain.C"},
    {"HoN.Core_Box.Terrain.D"},
}
becomes
{
    {"HoN.Core_Box.Terrain.A". {index = { 4,11}               }},   -- Tile (1,2) has the index ( 4,11) for its center space.
    {"HoN.Core_Box.Terrain.B", {index = {11,11}, rotation = 90}},   -- Tile (2,2) has the index (11,11) for its center space.
    {"HoN.Core_Box.Terrain.C". {index = { 4, 4}               }},   -- Tile (1,1) has the index ( 4, 4) for its center space.
    {"HoN.Core_Box.Terrain.D", {index = {11, 4}               }},   -- Tile (2,1) has the index (11 ,4) for its center space.
}
--]]
function Battlefield._AddIndexToTerrainTiles(terrainTiles, width, height)
    local i = 0
    for y = height, 1, -1 do    -- Height is measured in terrain tiles.
        for x = 1, width do     -- Width  is measured in terrain tiles.
            i = i + 1
            local tile = terrainTiles[i]

            if type(tile[2]) ~= "table" then
                -- Add empty "options" to this element if it doesn't already have any options.
                tile[2] = {}
            end

            -- The index is the center space of the terrain tile.
            local coordX = 4 + 7*(x-1)
            local coordY = 4 + 7*(y-1)
            tile[2].index = {coordX, coordY}
        end
    end
end
