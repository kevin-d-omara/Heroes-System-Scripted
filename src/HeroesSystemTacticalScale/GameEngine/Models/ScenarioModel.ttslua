#include <BattlefieldModel>
#include <TurnCounterModel>

--[[
## Class
public class ScenarioModel
{
    -- Public Fields
    BattlefieldModel Battlefield
    TurnCounterModel TurnCounter
    dictionary<PlayerModel> Players
    TeamsModel Teams

    -- Constructors
    public ScenarioModel:new(data)
    public ScenarioModel(data)
}

## Summary
Container for all physical components of a Scenario.
--]]

ScenarioModel = {}

-- Can create a new ScenarioModel instance by calling either ScenarioModel:new() or just ScenarioModel().
setmetatable(ScenarioModel, { __call = function(self, ...) return self:new(...) end })

--[[
## Parameters
<table> data: A table with the following key-value pairs:
    <table> Battlefield: See constructor for BattlefieldModel.
    <table> TurnCounter: See constructor for TurnCounterModel.
    <table<table>> Players: See constructor for PlayerModel.
    <table> Teams: See constructor for TeamsModel.
--]]
function ScenarioModel:new(data)
    if type(data) ~= 'table' then error("Argument [1] data: table expected, but got " .. type(data) .. ".") end
    if type(data.Battlefield) ~= 'table' then
        error("Argument [1] parameters.Battlefield: table expected, but got " .. type(data.Battlefield) .. ".")
    end
    if type(data.TurnCounter) ~= 'table' then
        error("Argument [2] parameters.TurnCounter: table expected, but got " .. type(data.TurnCounter) .. ".")
    end
    if type(data.Players) ~= 'table' then
        error("Argument [3] parameters.Players: table expected, but got " .. type(data.Players) .. ".")
    end

    local obj = {}
    setmetatable(obj, self)
    self.__index = self
    self.__call = function(self, ...) return self:new(...) end

    obj.Battlefield = BattlefieldModel(data.Battlefield)
    obj.TurnCounter = TurnCounterModel(data.TurnCounter)
    obj.Players = {}
    for k,v in pairs(data.Players) do
        obj.Players[k] = PlayerModel(v)
    end

    return obj
end
